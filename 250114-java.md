### 1.오브젝트 클래스 내부의 equals 함수는 어떻게 구현이 되어있을까?
Object 클래스의 기본 equals 메서드는 객체의 참조를 비교하도록 구현되어 있습니다.
객체가 같은 메모리 주소를 가리키고 있는지 확인합니다.
Object 클래스의 equals 함수는 == 동등 연산자와 동일한 기능을 하게됩니다.
equals 함수가 객체의 주소값이 아닌 내부의 값이 같은 지를 비교하고 싶다면 object 클래스의 equals 함수를 재정의해야합니다.
자바 표준 라이브러리 내에서 사용하고 있는 주요 클래스들 대부분이 equals 함수를 재정의해서 내부의 값을 비교하도록 오버라이딩이 되어있습니다.

### 2.자바의 특징은 무엇이 있을까요?
자바의 특징으로는 객체 지향적이고 어떠한 환경이든 JVM 위에서 동작하므로 환경적인 요소에 의존적이지 않다고 할 수 있습니다.
그 말은 환경적인 요소에 따라서 소스코드가 변경될 필요가 없다는 말이고 따라서 다양한 운영체제에서 동일한 코드를 실행할 수 있는 이식성이 높습니다. 이것은 자바의 특징입니다.
대신에 JVM이 환경적인 요소에 대신 의존성을 가지게됩니다.
또 다른 특징으로는 GC가 있는데 다른 언어의 경우에는 생성한 객체에 대해서는 개발자가 명시적으로 메모리에서 생성한 객체에 대해서 할당 해제를 해줘야하지만
자바에서는 오래되거나 사용되지 않는 객체를 자동으로 제거하여 메모리를 관리합니다.
또한 자바는 컴파일 언어와 인터프리터 언어의 특징을 결합한 형태의 언어입니다.
java언어를 .class 바이트코드로 컴파일하여 jvm 위에서 바이트코드를 한 줄씩 읽고 명령을 수행하게됩니다.

### 3.자바코드가 실행되기위한 내부동작과정은 무엇이 있을까요?
소스코드가 실행되기 위해서는 OS가 인식할 수 있는 실행코드(바이너리코드)로 변환이 되어야합니다.
자바에서는 자바 컴파일러에 의해서 JVM에서 실행될 수 있는 바이트코드로 컴파일이됩니다.
이 후에 변경된 바이트코드를 JVM 엔진이 각 바이트코드를 한 줄씩 해석하여 실행하게됩니다.
JVM 내에서 해석은 인터프리터가 컴파일(변환)은 JIT컴파일러가 동작하게됩니다.
JIT 컴파일러는 인터프리터 과정에서 자주 사용되는 바이트코드(핫스팟)를 기계어로 변환하여 메모리에 저장(캐싱)합니다.

### 4.변환(compile)과 해석(interpret)의 차이
이해가 안되었던 포인트
cpu는 바이너리코드를 통해서만 실행될 수 있다. 그렇다며 인터프리터 실행 과정 중에서도 명령이 실행될려면 결국에는 바이너리코드로 변환되어야한다고 생각했다.
인터프리터나 VM의 경우에는 이미 기계어(바이너리코드)로 작성된 프로그램이다. 결국 바이너리코드를 변환하는게 아니라 바이트코드를 입력값으로 받아 인터프리터나 VM에 이미 작성되어있는 기계어로 바이트코드를 처리하는 것이다.

### 5.바이트코드와 바이너리코드의 차이는 무엇인가요?
바이트코드와 바이너리코드(기계어)는 동치라고 생각했었다
바이트코드는 소스코드를 컴파일해서 나온 중간형태의 소스코드입니다. CPU가 직접 실행하는 것이 아니라 가상머신(VM)이나 인터프리터가 이 코드를 읽고 바이너리코드로 해석합니다.
또한 프로세서에 종속되지 않습니다. 다양한 OS/하드웨어에서 동일 코드를 실행할 수 있게합니다.

바이너리코드는 CPU가 직접 이해하고 실행할 수 있는 형태의 명령어 집합입니다.
특정 CPU마다 기계어 명령어 구조가 다르므로 한 플랫폼에서 생성된 기계어는 다른 플랫폼에서는 호환되지 않습니다.

바이트코드가 생성된 이유는 os나 하드웨어에 종속되지않도록하기 위해 생성된 코드이다.
만약 소스코드를 바이트코드로 변환 후 사용하지 않는다면 cpu마다 os마다 그에 맞는 바이너리코드를 생성해야할 것이고 그렇다면 환경에 맞춰서 원본 소스코드를 수정해야할 것이다.
결국 바이트코드가 생겨난 이유는 WORA(Write Once, Run Anywhere)을 위한 것이다 직역하자면 한번의 작성으로 어디에서든지 실행하기 위함이다.

### 6.JIT는 무엇인가?
(Just-In-Time) 컴파일러는 바이트코드를 기계어로 변환하는 컴파일러입니다.
JVM 내부의 실행엔진에 포함되어있습니다.
런타임 과정에서 자주 사용하는 바이트코드(핫스팟)를 한 번에 기계어로 변환 후 캐싱하여 성능을 최적화합니다.

### 7.객체지향이란?
캡슐화란 하나의 클래스가 캡슐이라고 생각하면 이해가 쉬울 것 같습니다.
클래스에 내부의 구현이 외부에 미치는 영향을 최소화하고 다른 객체들과 결합도를 낮추는 것을 목표로 합니다.
또한 외부접근을 최소화하는 것을 목표로 합니다. 객체의 내부 데이터를 아무때나 변경할 수 있게되면 유지보수 측면에서 보자면 어디서 값이 변경되었는지 예측하기 어려워집니다.

상속은 부모클래스의 기능을 자식클래스에서 사용할 수 있게 되는 건데 자식클래스는 부모클래스의 기능에 더해서 본인만의 기능을 추가해야할 것입니다. 자식클래스는 본인만의 아이덴티티를 가지고 있어야할 것입니다.

프로그래밍에서 다형성이란 하나의 인터페이스나 메소드가 여러 형태로 동작할 수 있음을 말합니다. 예를 들어 행위란 인터페이스를 만들고 메소드 내에 동작 메소드 있다면
행위라는 인터페이스를 구현한 클래스는 동작 메소드를 다양한 형태로 구현할 수 있을 것입니다. 어떤 것은 창던지기, 발차기 등등 같은 이름이지만 다른 동작을 하는 그런 것을 다형성이라고합니다.
또는 같은 메소드 이름이라도 매개변수의 타입이나 개수에 따라 다르게 동작하게 구현할 수 있을 것입니다. 이것 또한 다형성의 한 예로 볼 수 있습니다.

추상화란 객체가 가져야할 속성이나 기능에 대해서 모델링하는 과정을 말합니다. 예를 들어 추상클래스나 인터페이스가 있을 것인데
추상클래스에서 구현해야할 기능들을 나열한 후 상속받는 자식클래스에서 구현하도록 강제하는 형태를 가집니다. 여기서 추상클래스는 직접적인 기능은 없고 구현해야할 기능들의 목록만 나열해놓았습니다.
인터페이스에서도 구현해야할 기능들을 나열한 후 해당 인터페이스를 구현하는 클래스에서 인터페이스의 기능을 재구성하도록 강제합니다.
추상클래스나, 인터페이스처럼 직접적인 기능은 없고 객체가 가져야할 기능이나 속성에 대해서 모델링만 해놓은 것을 추상화라고 합니다.

### 8.객체의 특징
클래스는 인스턴스를 생성하기위한 설계도이며 클래스로 생성된 인스턴스는 각각의 별개의 상태 값과 주소을 가집니다.
클래스는 필드와 메소드로 구성되어있고 객체는 생성자를 통해 생성하게됩니다. 생성된 객체는 heap영역에 저장되며 참조변수는 스택영역에 저장되게됩니다.
예를 들어 A a = new A(); 에서 A a 는 참조 변수이고 new A()는 생성된 객체입니다. 생성된 객체는 GC에 의해 제거됩니다.

### 9.String 클래스의 equals()의 동작방식
object의 equals란 == 동등연산자와 동일한 기능을 한다. 객체의 참조주소를 비교하게됩니다.
String에서는 내부의 값을 비교하기 위해 equals 메소드를 재정의하는데
최초에 참조주소 값이 같다면 true를 반환하고 다르다면 내부적으로 각 문자열의 문자를 한글자씩 비교하게됩니다.

### 10.해시기반 자료구조에서 equals()의 동작방식
containsKey 동작방식
해시기반 자료구조에서는 값의 비교시 먼저 비교값을 해쉬함수(hashCode())를 통해 해시 값을 비교하게됩니다.
이 후 해시 함수로 나오게된 해쉬 값에 위치한 데이터들을 equals함수로 비교하게됩니다.
이 때 equals함수의 동작 방식은 데이터의 타입에 맞춰 동작하게됩니다.
containsValue 동작방식
containsValue의 경우에는 해시자료함수의 있는 모든 값을 비교하기 때문에 n의 개수만큼 값을 비교하게됩니다.

### 11.블록스코프에 안과 밖 어디에 변수를 선언에 대한 차이
    1번 코드
    	for (int i = 0; i < 5; i++) {
    		String s = new String("Hello"); 
    	}
    
    2번코드
    	String s
    	for (int i = 0; i < 5; i++) {
    		s = new String("Hello"); 
    	}
	
블록스코프 밖에 변수를 선언하게되면 스택메모리 상에 하나의 변수가 생성되고 반복문 내내 스택메모리에 존재하게됩니다.
블록스코프 안에 변수를 선언하게되면 해당 변수의 생명주기는 반복문이 끝날 때마다 제거되므로 반복문이 끝날때마다 스택메모리에 생성되고 제거되고를 반복하게됩니다.
사실 메모리상에 효율성 측면에서는 차이가 미미한 것 같다. 반복문을 통해 생성된 변수가 스택메모리에 계속해서 쌓이는게 아니라 생성되고 삭제되기를 반복하기 때문에 문제가 없고
오히려 가독성 측면에서 코드1이 더 유리한 측면이 있는 것 같다. 예를 들어 1번코드의 s변수는 블록스코프 안에서만 존재하기 때문에 스코프 밖에서 어디서 참조해도되는지 신경 쓸 필요가 없다.
또한 2번코드의 경우 반복문이 끝나면 스택메모리에 하나의 변수가 제거되어야하는데 반복문이 끝나도 스택메모리에 계속해서 남아있게된다.
