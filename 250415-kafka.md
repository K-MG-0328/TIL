## 요청-응답 방식(HTTP)와 비동기 이벤트 기반(Message Queue) 방식의 차이
![image](https://github.com/user-attachments/assets/44e158e9-2f84-4c4c-a046-697ef100002c)  

### 토픽(Topic)과 그룹아이디(Group ID)
#### 토픽
메시지를 발행하고 소비하는 채널 같은 개념 **생산자(Producer)** 는 메시지를 특정 토픽으로 전송한다.
**소비자(Consumer)** 는 해당 토픽을 구독하여 메시지를 받아간다.  
#### 그룹아이디
소비자 그룹(Consumer Group)을 구분짓는 ID, 같은 Group ID를 사용하는 여러 소비자 인스턴스는 협업하여 메시지를 처리합니다. 한 Group 내에 하나의 인스턴스가 하나의 메시지를 처리합니다.
서로 다른 Group ID는 서로 독립적으로 하나의 메시지에 대해서 각각 처리합니다.  

**이해하기 어려웠던 포인트 정리**. 

**그룹이 컨슈머 클래스의 그룹이 아니다. 컨슈머 클래스의 인스턴스의 그룹이다.**  
Kafka의 Group ID는 동일한 기능을 하는 Consumer 인스턴스들끼리 묶기 위한 것입니다.
즉, @KafkaListener나 Consumer를 여러 개 띄울 때, 동일한 Group ID를 설정하면 동일한 메시지를 서로 나눠서 처리합니다.  
예를 들어 서로 다른 기능을 하는 A 컨슈머와 B 컨슈머 클래스가 있는데 해당 클래스들의 그룹 아이디를 동일한 그룹 아이디로 하면 안된다. 그룹 아이디는 해당 클래스의 인스턴스를 그룹으로 만들기 위한 것이다.

인스턴스와 파티션의 개념 

그럼 왜 이렇게 하는가?

하나의 컨슈머 인스턴스는 하나의 스레드를 할당받아 풀링하는 방식으로 메시지를 처리한다. 
그런데 하나의 컨슈머 클래스의 인스턴스를 확장하여 2개의 스레드로 처리하게 한다면 동일한 메시지를 같은 기능을 하는 컨슈머 클래스가 처리할 수도 있기 때문이다. 

그럼 서로 다른 기능을 하는 컨슈머를 같은 그룹아이디로 두게되면 어떻게 될까?

두 개의 컨슈머가 하나의 그룹 내에서 메시지를 처리하므로 하나의 기능만 처리되고 하나는 처리되지 않을 것이다.

그럼 같은 기능을 하는 컨슈머 인스턴스는 왜 메시지를 그룹으로 지정하지 않으면 메시지를 중복처리할 수도 있는 것일까?

카프카 안에 큐를 컨슈머가 읽는다 하더라도 큐에 있는 메시지는 빠져서 사라지지 않기 때문이다. 
그룹이 컨슈머 클래스의 그룹이 아니다. 컨슈머 클래스의 인스턴스의 그룹이다. 
예를 들어 서로 다른 기능을 하는 A 컨슈머와 B 컨슈머 클래스가 있는데 해당 클래스들의 그룹 아이디를 동일한 그룹 아이디로 하면 안된다. 그룹 아이디는 해당 클래스의 인스턴스를 그룹으로 만들기 위한 것이다.

그럼 왜 이렇게 하는가?

하나의 컨슈머 인스턴스는 하나의 스레드를 할당받아 풀링하는 방식으로 메시지를 처리한다. 
그런데 하나의 컨슈머 클래스의 인스턴스를 확장하여 2개의 스레드로 처리하게 한다면 동일한 메시지를 같은 기능을 하는 컨슈머 클래스가 처리할 수도 있기 때문이다. 

그럼 서로 다른 기능을 하는 컨슈머를 같은 그룹아이디로 두게되면 어떻게 될까?

두 개의 컨슈머가 하나의 그룹 내에서 메시지를 처리하므로 하나의 기능만 처리되고 하나는 처리되지 않을 것이다.

그럼 같은 기능을 하는 컨슈머 인스턴스는 왜 메시지를 그룹으로 지정하지 않으면 메시지를 중복처리할 수도 있는 것일까?

카프카 안에 큐를 컨슈머가 읽는다 하더라도 큐에 있는 메시지는 빠져서 사라지지 않기 때문이다. 

### 요청-응답 방식 (HTTP)의 스레드 모델과 Kafka 기반 이벤트 처리의 스레드 모델

![image](https://github.com/user-attachments/assets/70067e81-19a5-4c7e-9b71-b21124910ff0)


### 풀링방식과 푸시 방식의 차이
