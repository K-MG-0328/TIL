## 원자적 연산이란?
컴퓨터 과학에서 사용하는 원자적 연산(AtomicOperation)의 의미는 해당 연산이 더 이상 나눌 수 없는 단위로 수행된다는 것을 의미합니다. 즉, 원자적 연산은 중단되지 않고, 다른 연산과 간섭 없이 완전히 실행되거나 전혀 실행되지 않는 성질을 가지고 있습니다.  
멀티스레드 상황에서 다른 스레드의 간섭 없이 안전하게 처리되는 연산입니다.  

예를 들어 
int i = 1 다음 연산은 둘로 쪼갤 수 없는 원자적 연산이다. 
int i = 1; 연산 중에, 다른 스레드가 i를 읽으면 “0에서 1로 바뀌어가는 중간 단계”를 보지 않고, 오직 0(바뀌기 전 값) 또는 1(바뀐 후 값) 만 보게 됩니다.
자바 메모리 모델에서 int는 단일 32비트로 읽고 쓰는 것이 보장됩니다. 즉, CPU 차원에서 한 번의 쓰기 명령으로 처리되는 것이 일반적이므로, 중간 상태(절반만 쓰임)를 볼 일이 없습니다.

## long / double 처럼 64bit(8byte) 자료형에 대입은 원자적 연산이 아닌 것인가?
만약 cpu나 JVM이 32bit 환경이라면 64bit 자료형인 long / double은 32bit 단위로 쪼개져 두 번의 연산으로 이뤄질 수 있으므로 중간 값(일부만 쓰인 값)이 관측될 수 있고 cpu나 JVM이 64bit 환경이라면 long / double은 한 번의 연산으로 처리가 될 것이므로 원자적 연산으로 처리될 것입니다.  
하지만 자바에서는 64비트 연산은 무조건 원자적이다라고 보장하지 않으므로 volatile, AtomicLong, synchronized 같은 동기화 수단을 이용해야합니다.   

## volatile은 무엇인가?
volatile는 자바에서 변수 선언부에 붙일 수 있는 키워드로, 멀티스레드 환경에서 가시성(visibility), 재배치 방지(Ordering)를 보장합니다. 

    private volatile int days;

### 가시성(visibility)을 보장한다는 것을 무엇을 말하는걸까?
가시성이라는 것은 "한 스레드가 변수의 값을 수정했을 때 다른 스레드가 그 변경된 값을 언제 볼 수 있는가?" 에 대한 문제입니다.   
멀티스레드 환경에서 원자적이지 않은 연산의 경우에는 한 스레드에서 쓰기 작업을 하고 있을 때 동시에 다른 스레드가 읽기 작업을 하게되면 중간 상태 값이 보이게되고 엉뚱한 값이 표출되게 될 수 있습니다.
예를 들어 32bit 환경에서 64비트 자료형을 대입한다고하면 cpu는 64비트 자료형에 대해서 한번에 처리할 수 없으므로 2번의 연산을 처리할 것입니다. 그 과정에서 하위 32비트 상위 32비트 씩 값을 변경한다고 했을 때 하위 32비트 값만 변경되었을 때 다른 스레드에게 그 값이 표출될 수 있습니다.
가시성을 보장한다는 말은 한 스레드가 volatile 키워드를 사용한 변수에 쓰기 작업을 한다고 했을 때 중간 상태 값을 CAS 기법을 이용해서 읽기 작업을 하는 스레드가 중간 상태 값이 아닌 이전 값 또는 완전히 변경된 값을 보여주게됩니다. 
즉, 스레드가 완전한 쓰기 작업을 끝내기 전까지의 가장 최신의 값(이전 값) 그리고 쓰기 작업을 끝낸 후에 가장 최신 값(이후 값)을 보도록합니다.  

### 재배치 방지는 무엇을 말하는걸까?
컴파일러 또는 CPU 차원에서 성능 최적화를 위해 프로그램의 일부 명령들을 원래 소스 코드 순서와 다르게 실행하거나 메모리에 기록하는 순서를 바꾸는 것을 말합니다.   
단일 스레드 관점에서는 이러한 재배치가 프로그램의 최종 결과가 같다면 문제되지 않습니다. 그러나 멀티스레드 환경에서는 다른 스레드가 해당 변수(메모리)를 읽는 시점이 달라져 "내가 예상한 순서대로 값이 관측되지 않는다"는 문제가 생길 수 있습니다.
단순하게 예를 들어 

    x = 1;   // (1)
    y = 2;   // (2)

라는 코드가 존재할 때 컴파일러나 CPU가 (2)번 문장을 먼저 실행 → 메모리에 기록한 뒤 그 다음 (1)번 문장을 실행할 수 있습니다.  
단일 스레드라면 결과는 같을 수 있지만, 다른 스레드가 x와 y를 동시에 읽고 있다면 “y가 이미 2가 되었는데 x는 아직 0” 같은 상황을 보게 되어, 프로그래머 예상(“x를 1로 먼저 바꾼 다음 y를 2로 바꿨으니, y가 2라면 x도 1이겠지”)을 깨버립니다.  
volatile로 선언된 변수는 volatile 키워드로 선언한 변수 기준으로 읽기/쓰기에 대해서 volatile 변수의 이전의 모든 메모리 연산은 volatile 변수보다 앞서 완료되어야하고 이후의 모든 메모리 연산은 volatile 변수 이후의 수행되어야합니다.   
재배치 방지(Ordering guarantee) 는 멀티스레드 환경에서 정해진 순서대로 명령어가 실행되었다고 ‘관측’되도록 보장하는 것을 의미합니다.  






