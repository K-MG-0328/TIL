### 토픽(Topic)과 그룹아이디(Group ID)
#### 토픽
메시지를 발행하고 소비하는 채널 같은 개념 **생산자(Producer)** 는 메시지를 특정 토픽으로 전송한다.
**소비자(Consumer)** 는 해당 토픽을 구독하여 메시지를 받아간다.  
#### 그룹아이디
**소비자 그룹(Consumer Group)** 을 구분짓는 ID, 같은 Group ID를 사용하는 여러 소비자 인스턴스는 협업하여 메시지를 처리합니다. 한 Group 내에 하나의 인스턴스가 하나의 메시지를 처리합니다.
서로 다른 Group ID는 서로 독립적으로 하나의 메시지에 대해서 각각 처리합니다.  

**그룹이 컨슈머 클래스의 그룹이 아니다. 컨슈머 클래스의 인스턴스의 그룹이다.**  
Kafka의 Group ID는 동일한 기능을 하는 Consumer 인스턴스들끼리 묶기 위한 것입니다.
즉, @KafkaListener나 Consumer를 여러 개 띄울 때, 동일한 Group ID를 설정하면 동일한 메시지를 서로 나눠서 처리합니다.  
예를 들어 서로 다른 기능을 하는 A 컨슈머와 B 컨슈머 클래스가 있는데 해당 클래스들의 그룹 아이디를 동일한 그룹 아이디로 하면 안된다. 그룹 아이디는 해당 클래스의 인스턴스를 그룹으로 만들기 위한 것이다.

**인스턴스와 스레드, 파티션의 개념**  
•	인스턴스(Instance). 
인스턴스는 하나의 어플리케이션이 실행될 때 생성되는 실행 단위로, 운영체제에서 말하는 프로세스 개념에 해당한다.  
하나의 서비스를 여러 서버나 컨테이너에 배포하여 서버 이중화 또는 수평 확장을 하게 되면, 어플리케이션 인스턴스도 그 수만큼 늘어난다.  
•	스레드(concurrency)  
Kafka 컨슈머에서 @KafkaListener(concurrency = N) 옵션은 하나의 인스턴스 내부에서 메시지를 병렬로 처리하기 위한 스레드 수를 의미한다.  
이 설정을 통해 인스턴스 하나당 N개의 Kafka 컨슈머 스레드가 생성되어, 파티션이 충분할 경우 병렬 처리를 가능하게 한다.  
•	파티션(Partition)  
파티션은 Kafka 토픽 내부에서 메시지를 저장하고 처리하는 논리적 단위이자 독립적인 통로이다.  
하나의 토픽이 여러 개의 파티션으로 나뉘어 있으면, Producer는 메시지를 보낼 때 3개의 파티션 중 하나를 선택하여 메시지를 전달하게 된다.  
파티션은 메시지 순서를 보장하며, 내부적으로는 로그(log) 구조로 동작한다.  

### 요청-응답 방식(HTTP)와 비동기 이벤트 기반(Message Queue) 방식의 차이
![image](https://github.com/user-attachments/assets/44e158e9-2f84-4c4c-a046-697ef100002c)  

### 요청-응답 방식 (HTTP)의 스레드 모델과 Kafka 기반 이벤트 처리의 스레드 모델

![image](https://github.com/user-attachments/assets/70067e81-19a5-4c7e-9b71-b21124910ff0)

### 풀링방식과 푸시 방식의 차이
폴링 방식은 클라이언트가 주기적으로 서버에 요청을 보내어 새로운 데이터가 있는지 확인하는 구조입니다. 이 방식은 구현이 간단하고 범용적으로 사용할 수 있다는 장점이 있지만, 실시간성이 떨어지고 불필요한 네트워크 요청이 반복적으로 발생할 수 있다는 단점이 있습니다. 예를 들어, 이메일 클라이언트가 10초마다 서버에 접속해 새로운 메일이 있는지 확인하는 것이 대표적인 폴링 방식입니다.  
  
반면, 푸시 방식은 서버에서 새로운 데이터나 이벤트가 발생했을 때 클라이언트에게 즉시 알림이나 데이터를 전송하는 구조입니다. 이 방식은 실시간성이 뛰어나 사용자 경험을 향상시킬 수 있으며, 메시지를 기다리는 대기 상태만 유지하면 되므로 불필요한 요청이 발생하지 않습니다. 대표적인 예로는 WebSocket을 활용한 실시간 채팅, 모바일 푸시 알림, 주식 가격 실시간 갱신 등이 있습니다.  

### Gateway, WebSocket 서버, API 서버, Kafka
<img width="558" alt="image" src="https://github.com/user-attachments/assets/1536f251-d7b1-4a71-88a4-d5a47b75c244" />   
  
배송이 시작되면 고객 앱은 WebSocket 서버에 연결을 맺어 실시간 알림을 받을 준비를 합니다. 이때 WebSocket 연결은 서버와의 지속적인 커넥션을 유지하며, 이후 별도의 요청 없이 서버로부터 데이터를 실시간으로 푸시(Push) 받을 수 있는 상태가 됩니다.  

한편, 라이더 앱은 자신의 위치 정보를 일정 주기(예: 5초)에 한 번씩 서버로 전송합니다. 이 위치 전송은 일반적인 HTTP 요청 기반의 폴링(Polling) 방식으로 구현되며, API Gateway를 통해 Delivery Service로 전달됩니다.  

Delivery Service는 라이더의 위치 데이터를 수신한 뒤, 해당 정보를 Redis Pub/Sub 또는 Kafka 같은 메시지 브로커에 이벤트 형태로 발행합니다. 예를 들어, delivery-location-updated라는 이벤트가 발행될 수 있습니다.  

WebSocket 서버는 이 메시지 브로커를 구독하고 있는 Consumer 역할을 하며, 발행된 이벤트를 수신합니다. 이벤트를 수신한 WebSocket 서버는 사전에 연결되어 있던 고객의 WebSocket 세션을 식별하고, 해당 고객에게 위치 정보를 실시간으로 푸시합니다.  

결과적으로 고객은 별도의 요청 없이도 라이더의 최신 위치를 실시간으로 전달받을 수 있으며, 라이더는 단순한 위치 전송만으로도 실시간 서비스를 지원할 수 있게 됩니다.  

**게이트웨이**  
클라이언트가 여러 마이크로서비스를 직접 호출하게 되면 인증, 보안, 요청 형식 통일 등이 어려워집니다. 
그래서 API 게이트웨이를 통해 요청을 중앙집중적으로 처리하고 각 서비스로 라우팅합니다.   
API 요청의 진입점 역할이며, 통합 인증/인가, 로깅, 트래픽 제어 등을 한 곳에서 관리할 수 있습니다.  
  
**게이트웨이 예시**  
Spring Cloud Gateway, NGINX, AWS API Gateway
  
**웹소켓 서버**  
서버와 클라이언트 간의 지속적인 연결을 유지하는 서버로 최초의 요청 이후 서버에서 클라이언트로 데이터를 실시간 데이터를 Push 하기위한 서버. 
   
**Kafka**  
데이터(이벤트)를 생산자(Producer)가 보내고, 여러 소비자(Consumer)가 이를 구독하여 처리할 수 있게 해주는 “중간 전달자”입니다.  

### 카프카 메시지 처리 흐름
생산자가 메시지를 특정 토픽의 파티션에 발행 메시지는 디스크에 저장됨(Append-Only Log 구조)
-> 소비자는 자식이 구독하고 있는 토픽의 파티션을 poll 하여 읽지 않은 메시지를 가져가고 처리 -> 소비자가 메시지를 처리하면 **오프셋(offset)** 을 커밋(자동/수동)에 따라 갱신

**오프셋이란**  
각 파티션의 메시지는 순차적으로 저장되며, 각 메시지에는 고유한 번호(offset)가 붙습니다. 이 offset을 기준으로 소비자가 어디까지 메시지를 읽었는지 관리합니다. 카프카는 오프셋을 “토픽(Topic) + 파티션(Partition) + 소비자 그룹(Consumer Group)” 단위로 관리합니다.
즉, 같은 토픽이라도 그룹이 다르거나, 같은 그룹이라도 파티션이 다르면 오프셋은 독립적으로 관리됩니다.  
예를 들어, 4가지 경우가 있다고한다면  
A토픽 : A그룹 : A파티션  
A토픽 : A그룹 : B파티션  
A토픽 : B그룹 : A파티션  
A토픽 : B그룹 : B파티션  
위의 4가지 경우 모두 서로 다른 조합이기 때문에 오프셋을 별도로 저장,관리합니다.  

**Append-Only Log구조란**  
새로운 데이터를 기존 파일 끝에 계속해서 덧붙이는 방식으로 데이터를 저장하는 구조입니다.    
해당 파티션의 끝에 메시지를 순서대로 추가 -> 삭제하거나 덮어쓰지 않음 -> 각 메시지는 자동으로 고유 번호(offset)가 붙음

### 메시지는 파티션에 남아있는데 이 메시지는 언제 처리되는가?
카프카는 메시지를 소비자가 읽었는지 여부와 관계없이 설정한 보존 기간만큼 보관합니다.  


### Circuit Breaker / TimeOuts / Retry 정책

